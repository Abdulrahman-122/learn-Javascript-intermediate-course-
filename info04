1.

We provided a function withConstructor() which takes in a number. If the number is 0, it returns a promise that resolves to the string 'zero'. If the number is not 0, it returns a promise that resolves to the string 'not zero'. Take a moment to understand this function and the code that follows.

When you’re ready to run it, type node app.js into the terminal and press enter, then select “Check Work” to continue.
Checkpoint 2 Passed

2.

Write an async function, withAsync(), that reproduces the functionality of withConstructor(). Though your function will return a promise, it should not construct the promise using the new keyword. Instead, it should rely on the fact that an async function automatically returns a promise.

When you’re ready, check your work to move on to the next step.
Checkpoint 3 Passed

3.

Now test your code! Uncomment the test code we wrote at the bottom of app.js. In the terminal, type node app.js and press enter to execute the code.

Be sure to click “Check Work” after running the command to pass this checkpoint and move on to the next exercise.

solution;

function withConstructor(num){
  return new Promise((resolve, reject) => {
    if (num === 0){
      resolve('zero');
    } else {
      resolve('not zero');
    }
  });
}

withConstructor(0)
  .then((resolveValue) => {
  console.log(` withConstructor(0) returned a promise which resolved to: ${resolveValue}.`);
});

// Write your code below:

// async function withAsync(num){
//   if (num===0){
//     return('zero');

//   }
//   else{
//     return 'not zero';
//   }
// }
// you can build the promise as below or above all the same;

const withAsync=async(num)=>{
   if (num===0){
    return('zero');

  }
  else{
    return 'not zero';
  }
}

withAsync(0).then(resolveValue=>{
  console.log(` withConstructor(0) returned a promise which resolved to: ${resolveValue}.`);
});


// Leave this commented out until step 3:

withAsync(100)
  .then((resolveValue) => {
  console.log(` withAsync(100) returned a promise which resolved to: ${resolveValue}.`);
})









1.

In the provided code, we’ve imported the function brainstormDinner(). This function expects no arguments and returns a new promise with a resolved value of a string representing a meal. (You can look at the code for this function by navigating to the library.js file.)

Look at the nativePromiseDinner() function in app.js. Take a moment to understand this function and predict its expected outcome. In the next step, you’ll be recreating its functionality using async...await rather than native promises.

It’s not necessary to execute the nativePromiseDinner() function, but if you’d like to, check out the hint for some guidance. Press “Check Work” when you’re ready to move on to the next step.
Checkpoint 2 Passed

2.

Fill in the body of the announceDinner() function so that it has the same functionality as nativePromiseDinner(). It should wait for the promise returned from brainstormDinner() to resolve, and then log a string to the console in the same format as did nativePromiseDinner(). You’ll need to use the await operator inside your function.

When you’re ready, check your work to move on to the next step.
Checkpoint 3 Passed

3.

At the bottom of app.js, beneath the function declaration, invoke the announceDinner() function.
Checkpoint 4 Passed

4.

In the terminal type node app.js and press enter to execute your code.

Be sure to click “Check Work” after running the command to pass this checkpoint and move on to the next exercise.

solution;
/*
this is the brainstormDinner function. It's a little silly. It returns a promise that uses a series of setTimeout() functions to simulate a time-consuming asynchronous action. It's a good example of "callback hell" or "the pyramid of doom," two ways people describe how confusing a bunch of nested callback functions can become.
*/

const brainstormDinner = () => {
  return new Promise((resolve, reject) => {
  console.log(`I have to decide what's for dinner...`)
  setTimeout(() => {
    console.log('Should I make salad...?');
    setTimeout(() => {
      console.log('Should I make ramen...?');
      setTimeout(() => {
        console.log('Should I make eggs...?');
        setTimeout(() => {
          console.log('Should I make chicken...?');
          resolve('beans');
        }, 1000);
      }, 1000);
    }, 1000);
  }, 1000);
});
};
brainstormDinner();
module.exports = brainstormDinner;


const brainstormDinner = require('./library.js');


// Native promise version:
function nativePromiseDinner() {
  brainstormDinner().then((meal) => {
	  console.log(`I'm going to make ${meal} for dinner.`);
  });
}
// nativePromiseDinner();

// async/await version:
async function announceDinner() {
  // Write your code below:
  const resolved_val=await brainstormDinner();
  console.log(`I'm going to make ${resolved_val} for dinner.`);
  
}
announceDinner();

---
now if you want to use async-await to build a promise -> here it is 
  - as you know async-await -> are used to build a promise like native promise

ex;
Take a look at the provided code. We imported the shopForBeans() function from library.js which returns a promise with a resolved value of a string representing a type of bean, eg. ‘kidney’.

Next, we declared the getBeans() function. Let’s summarize its intended functionality:

    Log '1. Heading to the store to buy beans...' to the console.
    Capture the resolved value of the promise returned when we invoke shopForBeans().
    The promise returned from shopForBeans() prints a string in the format '2. I bought [the resolved type of beans] beans because they were on sale.'
    Finally, the function prints a string in the format '3. Great! I'm making [the bean type] beans for dinner tonight!' to the console.

Execute app.js in the terminal to see if getBeans() is working as intended, then press “Check Work”.
Checkpoint 2 Passed

2.

Uh oh, getBeans() is logging '3. Great! I'm making [object Promise] beans for dinner tonight!' to the console. Take a moment to understand why this is happening, and then refactor getBeans() so it works as intended. Check your work when you’re ready to move on to the next step.
Checkpoint 3 Passed

3.

To test that the code is now functioning properly, execute app.js in the terminal again.

Be sure to click “Check Work” after running the command to pass this checkpoint and move on to the next exercise.
solution;

this is library.js content;
/*
This is the shopForBeans function. It uses a setTimeout() function to simulate a time-consuming asynchronous action. The function returns a promise with a resolved value of a string representing a type of bean. It settles on a random beanType from the beanTypes array using Math.random().
*/

const shopForBeans = () => {
  return new Promise((resolve, reject) => {
	const beanTypes = ['kidney', 'fava', 'pinto', 'black', 'garbanzo'];
  setTimeout(()=>{
    let randomIndex = Math.floor(Math.random() * beanTypes.length);
    let beanType = beanTypes[randomIndex];
    console.log(`2. I bought ${beanType} beans because they were on sale.`);
   resolve(beanType);
  }, 1000);
});
}
  
module.exports = shopForBeans;





const shopForBeans = require('./library.js');

// function getBeans() {
//   console.log(`1. Heading to the store to buy beans...`);
//   let value = shopForBeans();
//   console.log(`3. Great! I'm making ${value} beans for dinner tonight!`);
// }

async function getBeans(){
  console.log(`1. Heading to the store to buy beans...`);
  let value=await shopForBeans();
    console.log(`3. Great! I'm making ${value} beans for dinner tonight!`);
}
getBeans();

after running this code;
$ node app.js 
1. Heading to the store to buy beans...
2. I bought kidney beans because they were on sale.
3. Great! I'm making kidney beans for dinner tonight!
$ node app.js 
1. Heading to the store to buy beans...
2. I bought garbanzo beans because they were on sale.
3. Great! I'm making garbanzo beans for dinner tonight!


----
so now we want to say ; async-await keywords -> are used to resolve the promise you did inside the function;
look at this ex;
1.

Take a look at the provided code. We require in three functions: shopForBeans(), soakTheBeans(), and cookTheBeans(). These functions each return a promise.

    shopForBeans() expects no arguments and returns a promise that will resolve to a string representing a type of bean.
    soakTheBeans() expects a string representing a type of bean as an argument and returns a promise that resolves to a boolean value, indicating whether or not the beans are softened.
    cookTheBeans() expects a boolean as an argument and, if that value is true, returns a promise which will resolve to a string announcing that dinner is ready.

If you’d like, look in library.js to see how these functions work. Press “Check Work” to move on to the next step.
Checkpoint 2 Passed

2.

In the following checkpoints, you’ll create an async function that handles the three dependent promises we just walked through. It will simulate shopping for, soaking, and then cooking the beans. To get started, declare an async function, makeBeans(). You can leave the function body blank for now.

Check your work to move on to the next step.
Checkpoint 3 Passed

3.

Inside your function, declare a variable, type, assigned to the resolved value of shopForBeans(). This must be accomplished in one statement.
Checkpoint 4 Passed

4.

Next, still in makeBeans, declare a variable, isSoft, assigned to the resolved value of soakTheBeans(). Don’t forget: the soakTheBeans() function expects an argument. Make sure to pass the expected value into soakTheBeans().
Checkpoint 5 Passed

5.

Next inside your function, declare a variable, dinner, assigned to the resolved of cookTheBeans(). Don’t forget: the cookTheBeans() function also expects an argument. Make sure to pass the expected value into cookTheBeans().
Checkpoint 6 Passed

6.

Next inside your function, log your dinner variable to the console.
Checkpoint 7 Passed

7.

Beneath your function declaration, invoke the makeBeans() function.
Checkpoint 8 Passed

8.

Let’s see your async function in action! In the terminal, type node app.js and press enter to execute the code. (Press “Check Work” when complete to continue)















/*
This is the shopForBeans function from the last exercise
*/

const shopForBeans = () => {
  return new Promise((resolve, reject) => {
	const beanTypes = ['kidney', 'fava', 'pinto', 'black', 'garbanzo'];
  setTimeout(()=>{
    let randomIndex = Math.floor(Math.random() * 5);
    let beanType = beanTypes[randomIndex];
    console.log(`I bought ${beanType} beans because they were on sale.`);
   resolve(beanType);
  }, 1000)
})
}

let soakTheBeans = (beanType) => {
   return new Promise((resolve, reject) => {
     console.log('Time to soak the beans.');
    setTimeout(()=>{
      console.log(`... The ${beanType} beans are softened.`);
      resolve(true);
      }, 1000);
  });
}

let cookTheBeans = (isSoftened) => {
  return new Promise((resolve, reject) => {
    console.log('Time to cook the beans.');
    setTimeout(()=>{
      if (isSoftened) {
        console.log('... The beans are cooked!');
        resolve('\n\nDinner is served!');
      }
    }, 1000);
  });
}

  
module.exports = {shopForBeans, soakTheBeans, cookTheBeans};

this is the app.js
const {shopForBeans, soakTheBeans, cookTheBeans} = require('./library.js');

// Write your code below:
async function makeBeans(){
  const type=await shopForBeans();
  const isSoft=await soakTheBeans(type);
  const dinner=await cookTheBeans(isSoft);
  console.log(dinner);
}
makeBeans();
output;
node app.js 
I bought black beans because they were on sale.
Time to soak the beans.
... The black beans are softened.
Time to cook the beans.
... The beans are cooked!


Dinner is served!

---
now how to catch error with async-await 
  - we use try()catch()
ex;
1.

For convenience, we’ve been working with a lot of promises that will never reject, but this isn’t very realistic!

This time we’ve imported a function, cookBeanSouffle(), which returns a promise that resolves or rejects randomly. When it resolves, the promise resolves with a value of 'Bean Souffle' and, when it rejects, it rejects with a value of 'Dinner is ruined!'. If you’re interested, you can see how the function works by looking at library.js.

Press “Check Work” when you’re ready to move on to the next step.
Checkpoint 2 Passed

2.

Declare an async function, hostDinnerParty(). Inside your function, create a try...catch statement. The catch statement should specify an identifier, error. You can leave both the try and catch blocks empty.
Checkpoint 3 Passed

3.

Inside your try block, log a string in the following format: '[resolved value of cookBeanSouffle() promise] is served!' ie. 'Bean Souffle is served!'. Make sure to await the cookBeanSouffle() promise. For more guidance, check out the hint.
Checkpoint 4 Passed

4.

Now let’s fill in the catch block! First log the error to the console, and then log the string: 'Ordering a pizza!' to the console.
Checkpoint 5 Passed

5.

Awesome! Beneath your function declaration, invoke hostDinnerParty().
Checkpoint 6 Passed

6.

Let’s see your function in action. In the terminal, type node app.js and press enter to run the code. If you keep executing app.js you’ll see the results of the promise resolving or rejecting.

Be sure to click “Check Work” after running the command to pass this checkpoint and move on to the next exercise.

solution;
const cookBeanSouffle = require('./library.js');

// Write your code below:
this is the library function;
// This function returns true 50% of the time.
let randomSuccess = () => {
 let num = Math.random();
 if (num < .5 ){
   return true;
 } else {
   return false;
 }
};

// This function returns a promise that resolves half of the time and rejects half of the time
let cookBeanSouffle = () => {
 return new Promise((resolve, reject) => {
   console.log('Fingers crossed... Putting the Bean Souffle in the oven');
   setTimeout(()=>{
     let success = randomSuccess();
     if(success){
       resolve('Bean Souffle');
     } else {
       reject('Orderomg a pizza!');
     }
   }, 1000);
 });
};

module.exports = cookBeanSouffle;



async function hostDinnerParty(){
  try{
    const resolvedVal=await cookBeanSouffle();
      console.log(`${resolvedVal} is served!`)
  }catch(error){
    console.log(error);
    console.log('Ordering a pizza!')

  }
}
hostDinnerParty();
output;
 node app.js 
Fingers crossed... Putting the Bean Souffle in the oven
Orderomg a pizza!
Ordering a pizza!
---
now what if you don't want to write await to resolve function when you equalized it to a new variable or you want to return the promise itself not it's value to the variable you can write the function itself without any await then at log you can write your await 
ex;
1.

Take a look at the provided code, where we’ve imported four functions: cookBeans(), steamBroccoli(), cookRice(), and bakeChicken(). Each of these functions returns a promise, which will resolve to a string representing a part of a meal.

If you’d like, check out library.js to see how these functions work. Press “Check Work” when you’re ready to move on.
Checkpoint 2 Passed

2.

Declare an async function, serveDinner(). Within the function body, create four variables:

    vegetablePromise, which should be assigned the return value of steamBroccoli()
    starchPromise, which should be assigned the return value of cookRice()
    proteinPromise, which should be assigned the return value of bakeChicken()
    sidePromise, which should be assigned the return value of cookBeans()

These variables should be assigned the promise objects themselves, not their resolved values.
Checkpoint 3 Passed

3.

Next, console.log() a string in the following format:

    Dinner is served. We’re having [resolved value of the vegetablePromise], [resolved value of the starchPromise], [resolved value of the proteinPromise], and [resolved value of the sidePromise]. 

i.e., “Dinner is served. We’re having broccoli, rice, chicken, and beans.”

You’ll need to await each promise, but there are a few different ways you can accomplish the desired functionality. Check out the hint if you want some guidance.
Checkpoint 4 Passed

4.

Awesome! Let’s see your function in action. Beneath your function declaration, invoke serveDinner().
Checkpoint 5 Passed

5.

In the terminal type node app.js and press enter to run the code.

Be sure to click “Check Work” after running the command to pass this checkpoint and move on to the next exercise.

solution;
these are the function we will import later;let cookBeans = () => {
  return new Promise ((resolve, reject) => {
   setTimeout(()=>{
     resolve('beans');
   }, 1000);
 });
}

let steamBroccoli = () => {
 return new Promise ((resolve, reject) => {
   setTimeout(()=>{
     resolve('broccoli');
   }, 1000);
 });
}

let cookRice = () => {
 return new Promise ((resolve, reject) => {
   setTimeout(()=>{
     resolve('rice');
   }, 1000);
 });
}

let bakeChicken = () => {
 return new Promise ((resolve, reject) => {
   setTimeout(()=>{
     resolve('chicken');
   }, 1000);
 });
}

module.exports = {cookBeans, steamBroccoli, cookRice, bakeChicken};

now in another file called ; app.js 
let {cookBeans, steamBroccoli, cookRice, bakeChicken} = require('./library.js');

// Write your code below:



async function serveDinner(){      // this is my solution
  const vegetablePromise=steamBroccoli();
  const starchPromise= cookRice();
  const proteinPromise=bakeChicken();
  const sidePromise= cookBeans();
  console.log(`Dinner is served. We're having ${await vegetablePromise}, ${await starchPromise}, ${await proteinPromise}, and ${await sidePromise}.`) ; }
serveDinner()
output;
node app.js 
Dinner is served. We're having broccoli, rice, chicken, and beans.
---
now we need to use ; Promise.all() as we used it with native promises in order to make  resolving or rejecting fast in single check instead of looking for each promise no 
we see if all promises into the promise.all have been correct -> send a single resolve 
if one of the promises send a reject -> no wait the ouput will be reject;
ex;


1.

In this exercise, we imported the same four functions as in the last exercise: cookBeans(), steamBroccoli(), cookRice(), and bakeChicken().

Each of these functions returns a promise, which will resolve to a string representing a part of a meal. You can check them out in the library.js file. Press “Check Work” to move on to the next step.
Checkpoint 2 Passed

2.

You’re going to create a function that is very similar to the serveDinner() function you created in the last exercise. This time, you’ll use Promise.all()!

Create an async function serveDinnerAgain(). Inside your function, declare a variable foodArray and assign it the resolved value of the promise returned from Promise.all().

Remember that Promise.all() takes in an array of promises. Pass in an array containing the steamBroccoli(), cookRice(), bakeChicken(), and cookBeans() function calls in that order.
Checkpoint 3 Passed

3.

Next, console.log() a string in the following format:

    Dinner is served. We’re having [first item in foodArray], [second item in foodArray], [third item in foodArray], and [fourth item in foodArray]. 

i.e., ‘Dinner is served. We’re having broccoli, rice, chicken, and beans.’

There are a few different ways you can accomplish the desired functionality. Check out the hint if you want some guidance.
Checkpoint 4 Passed

4.

Ok great! Now let’s see your function in action. Beneath your function declaration, invoke serveDinnerAgain().
Checkpoint 5 Passed

5.

In the terminal type node app.js and press enter to run the code.

Make sure to click “Check Work” to complete this step.

solution;
first look at the functions at library.js
let cookBeans = () => {
  return new Promise ((resolve, reject) => {
   setTimeout(()=>{
     resolve('beans');
   }, 1000);
 });
};

let steamBroccoli = () => {
 return new Promise ((resolve, reject) => {
   setTimeout(()=>{
     resolve('broccoli');
   }, 1000);
 });
};

let cookRice = () => {
 return new Promise ((resolve, reject) => {
   setTimeout(()=>{
     resolve('rice');
   }, 1000);
 });
};

let bakeChicken = () => {
 return new Promise ((resolve, reject) => {
   setTimeout(()=>{
     resolve('chicken');
   }, 1000);
 });
};
module.exports = {cookBeans, steamBroccoli, cookRice, bakeChicken};
here is the app.js


 let {cookBeans, steamBroccoli, cookRice, bakeChicken} = require('./library.js');

// Write your code below:


async function serveDinnerAgain(){
  const foodArray=await Promise.all([steamBroccoli(),cookRice(),bakeChicken(),cookBeans()]);
//   for (int i=0;i<foodArray.length;i++){
//    console.log(foodArray[i])
// }
  let vegetable=foodArray[0];
  let starch=foodArray[1];
  let protein=foodArray[2];
  let side=foodArray[3];
console.log(`Dinner is served. We're having ${vegetable}, ${starch}, ${protein}, and ${side}.`);;

}
serveDinnerAgain();
this is the output;
node app.js 
Dinner is served. We're having broccoli, rice, chicken, and beans.

---
to sum up
	- async-await -> is a suger syntactic that build on Native promise
	- async -> indicate to the asynchronous keyword -> await -> pause the executation of our function untill the promise resolve or reject
	- we use await -> many times 
	- we use => try-catch for error handling
	- we can use Promise.all() to return a single resolved value in case of all the items into the arrays that passed to it all resolved else if one of them rejected -> it will return  reject


---
what do you know about HTTPsor http?
	- it's called a hypertext transfer protocol
	- used to transfer data from the client to the server or the vice verse.
	- if the client(me) want the data from the server(google.com as example) -> it will send Get method on the http to that server to get the data I want
ex;
GET / HTTP/1.1
Host: www.codecademy.com
this is what http makes to get data from the server
	you need to understand -> before http works -> there's a protocol called TCP -> this open a session between the client,server in safe way to access data between them
	Get -> Get method 
	HTTP/1.1 -> this is the protocol that send to the server 
	Host;www.... -> this is the domain name of the server that client want to access
after sending this to the server ;
there are many cases but the famous of them is ; 200,404

HTTP/1.1 200 OK
Content-Type: text/html
if this returned from the server -> that means the server will respond to that client by sending data to it (like web page you see on chrome ...)
200 -> means yes ,  accept 
content-type -> means the data that will be sent to the clien are html/css type

if the response was this
HTTP/1.1 404 NOT FOUND
that means -> server refuse your order as you write the domain false or whatever .
404 -> means not found

after the data return to the user -> the session will stop -> tcp will stop and the process operates again when the user ask for another page ...

to sum up ;
HTTPS -> is is the important protocol in our life to access any page over the internet
tcp -> open the session between the client , server.
