Make api request using Fetch in Js 



Fetch Request API:
  - when call fetch -> it create a request (get response or whatever) to the end point and see whether the promise there is resolved correctly if yes return a true response 
  - we use this true response in .then later to return a json response from that object 
  - we can  handle error that output from that json by build a callback function (anonymos or whatever you want ) + build another call back function that handle resloved response from the fetch

  ex;

  1.

At the top of main.js, create a const variable called url. Assign url to the following URL as a string:

https://api.datamuse.com/words?sl=

Copy to Clipboard

The ?sl= portion of the string will be the start of your query string, which will be used to pass parameters to the Datamuse API. The query string will be used by the engine to narrow the search to words that sound like your word.
Checkpoint 2 Passed

2.

Within main.js, we have provided an empty getSuggestions() function. In the function body, create a const variable called wordQuery and assign it inputField.value.

We’ll need wordQuery to store the value of what is being typed into the input field.

Create another const variable called endpoint and assign it the value of a string that is url, and wordQuery concatenated in that order.

We will be working inside getSuggestions() function for the remainder of this exercise.
Checkpoint 3 Passed

3.

Inside the getSuggestions() function, call the fetch() function and pass in endpoint as an argument. For this API to work within the Codecademy browser, add { cache: 'no-cache' } as the second argument.
Checkpoint 4 Passed

4.

Chain a .then() method to the fetch() function. Pass an arrow callback function as its argument. The callback function should take response as its single parameter.
Checkpoint 5 Passed

5.

Inside the success callback function, create a conditional statement that checks if the ok property of the response object evaluates to a truthy value.

If so, return response.json().

By returning response.json(), the next .then() method chained to it will receive a Promise with JSON data.
Checkpoint 6 Passed

6.

Below the condition’s code block, throw an Error stating 'Request failed!' to raise an exception if the request failed.
Checkpoint 7 Passed

7.

Next, we will add a second argument to the .then() method to handle errors. Create an arrow function that takes one parameter, networkError.

In the code block of the arrow function, log networkError.message to the console.

Note that we will continue to add to this code in the next exercise to manipulate the webpage to see the word suggestions from Datamuse. The submit button will not return anything yet.

solution;
// Information to reach API
const url='https://api.datamuse.com/words?sl='

// Selects page elements
const inputField = document.querySelector('#input');
const submit = document.querySelector('#submit');
const responseField = document.querySelector('#responseField');

// Asynchronous function
const getSuggestions = () => {
  const wordQuery=inputField.value;
  const endpoint=url+wordQuery;
  fetch(endpoint,{cache:'no-cache'})
  .then(response=>{
    if(response.ok){
      return response.json();
    }
    throw new Error('Request failed!')
  },networkError=>{
    console.log(networkError.message
    )
  })
}

// Clears previous results and display results to webpage
const displaySuggestions = (event) => {
  event.preventDefault();
  while(responseField.firstChild){
    responseField.removeChild(responseField.firstChild);
  }
  getSuggestions();
};

submit.addEventListener('click', displaySuggestions);
----
now you must know; that
  - you can run your code either using modules -> which means you need to export ,import from file to file the functions you need
  - else you will work generally where all functions work inside a giant hall or a room
ex; in this example we used the general case which means you can run the js function inside other file without importing as we didn't use module as a type of them when using them inside HTML code

1.

After the existing .then() method, chain another .then() method.

As the first argument of our second .then() method, pass an anonymous arrow callback function that takes jsonResponse as its single parameter.
Checkpoint 2 Passed

2.

Inside the callback function we just created, call the renderRawResponse() function and pass in jsonResponse as its argument. Run the code.

In the input field, type in a word and click the submit button.

If all went well, we should see an array of words that the Datamuse API responded with!

Note that you can find the renderRawResponse() function declaration in public/helperFunctions.js. In this context, the function is available in main.js without any import statement.

Make sure that the renderRawResponse() function is called inside the second .then()‘s callback function.
Checkpoint 3 Passed

3.

Let’s format our response from the Datamuse API to look presentable on the webpage. To do this, we will use the renderResponse() function that’s been defined in public/helperFunctions.js.

Comment out renderRawResponse(jsonResponse). Then, call renderResponse(jsonResponse) instead.

Run your code.

Try the webpage again with another word!

now solution ;
// Information to reach API
const url = 'https://api.datamuse.com/words?sl=';

// Selects page elements
const inputField = document.querySelector('#input');
const submit = document.querySelector('#submit');
const responseField = document.querySelector('#responseField');

// Asynchronous function
const getSuggestions = () => {
  const wordQuery = inputField.value;
  const endpoint = `${url}${wordQuery}`;
  
  fetch(endpoint, {cache: 'no-cache'}).then(response => {   // fetch here return a get request as you pass to him the endpoint of the api then gives you the answer(get)
                                                            
    if (response.ok) {
      return response.json();
    }
    throw new Error('Request failed!');    
  }, networkError => {
    console.log(networkError.message)
  }).then(jsonResponse => {
    // renderRawResponse(jsonResponse); // solution
    renderResponse(jsonResponse);  =>solution   
  })
}

// Clears previous results and display results to webpage
const displaySuggestions = (event) => {
  event.preventDefault();
  while(responseField.firstChild){
    responseField.removeChild(responseField.firstChild);
  }
  getSuggestions();
};

submit.addEventListener('click', displaySuggestions);

------
How to make a request post in JS:
here's the first part of how to make an object ;
.

Set the value of the apiKey variable to your Rebrandly API key as a string.

If a correct key is not assigned, proper results will not be seen in the steps afterwards.
Checkpoint 2 Passed

2.

We will make our POST request inside the shortenUrl() function. Inside the code block of shortenUrl(), create a const variable named urlToShorten and assign it inputField.value. urlToShorten will keep the value of what is being typed into the input field.

Note that we will be working inside shortenUrl() for the remainder of this exercise.
Checkpoint 3 Passed

3.

Underneath the urlToShorten declaration, create another const variable named data and assign it to the stringified version of {destination: urlToShorten}. We can use the JSON.stringify() method to do this.

The data variable will be used to send the information, which needs to be in string format, to the request body.
Checkpoint 4 Passed

4.

Below our data variable declaration, call the fetch() function. Pass url as its first argument and an empty object as its second argument.
Checkpoint 5 Passed

5.

Now it’s time to add some properties to the empty object that you just created. Add a property with the key method and the value 'POST'.
Checkpoint 6 Passed

6.

In the same object, add another property. The key for this property is headers, and the value will be the following object:

{
  'Content-type': 'application/json',
  'apikey': apiKey
}

Copy to Clipboard

We will use this to connect to the API.
Checkpoint 7 Passed

7.

In that same object that has the properties method and headers, add another property. The key is named body and the value will be data.

We’ve now created an object containing all the information we need for our POST request!
solution;
// Information to reach API
const apiKey = 'd95f2635fca84191986d2679c0db5208';
const url = 'https://api.rebrandly.com/v1/links';

// Some page elements
const inputField = document.querySelector('#input');
const shortenButton = document.querySelector('#shorten');
const responseField = document.querySelector('#responseField');

// Asynchronous functions          // mysolution
const shortenUrl = () => {
  const urlToShorten=inputField.value;          
 const data=JSON.stringify({destination:urlToShorten});
 fetch(url,{method:'POST',headers:{'Content-type':'application/json','apikey':apiKey},body:data});
}

// Clear page and call Asynchronous functions
const displayShortUrl = (event) => {
  event.preventDefault();
  while(responseField.firstChild){
    responseField.removeChild(responseField.firstChild);
  }
  shortenUrl();
}

shortenButton.addEventListener('click', displayShortUrl);

the second part here is ;
1.

Chain a .then() method at the end of the fetch() function we wrote in the previous exercise. As its first argument, pass an arrow function as a callback that takes response as its single parameter.
Checkpoint 2 Passed

2.

Inside the callback function of .then(), use a conditional statement to check the value of the ok property of response. If it evaluates to a truthy value, return response.json().

Run the code.
Checkpoint 3 Passed

3.

Below the curly braces of the conditional statement, throw a new Error in case response.ok is falsy.

The error message should be 'Request failed!'.
Checkpoint 4 Passed

4.

As the second argument of the .then() method, add another arrow callback function that takes networkError as a single parameter.

Log the networkError.message inside of the callback function.

By adding this second callback, you’re safeguarding yourself in the rare event that the network returns an error!
Checkpoint 5 Passed

5.

Chain another .then() method to the end of the previous .then() method.
Checkpoint 6 Passed

6.

Pass in an anonymous arrow function as an argument for our second .then(). This callback function will take jsonResponse as its single parameter.

Inside the callback function, call renderResponse() and pass in jsonResponse.

The renderResponse() helper function can be viewed at public/helperFunctions.js.

Run the code.

Put in any URL in the text field, and then click the shorten button on the webpage. Make sure you include the entire link, including 'http://' or 'https://'.

solution;
fetch(url, {
    method: 'POST',              //this is how post request is done in JS
    headers: {
      'Content-type': 'application/json',
      'apikey': apiKey
    },
    body: data
  }).then(response =>{
    if (response.ok){
      return response.json();
    }throw new Error('Request failed!');
   
  },networkError=>{
    console.log(networkError.message);
  }).then(jsonResponse=>{
    renderResponse(jsonResponse);
  })
}

----
Async Get response
  - first you need for ; async to make a function Asynchronous while you are doing something else 
  - await -> suspend the entire program in order to  fetch the Get response from the endpoint  or even to send a Post response but in this example we are waiting for a Get response from the server
ex;
1.

Under the comment “Asynchronous function”, create a const variable called getSuggestions and set it to a new arrow function using the async keyword.

You’ll be coding inside the getSuggestions() function for the remainder of this exercise.
Checkpoint 2 Passed

2.

Inside the getSuggestions() function, create a const variable named wordQuery and assign it inputField.value.
Checkpoint 3 Passed

3.

Create another const variable called endpoint and assign it the value of a string that is url, queryParams, and wordQuery concatenated in that order.
Checkpoint 4 Passed

4.

Add a try statement with an empty code block. Outside the code block for try, add a catch(error) statement with a code block that logs error to the console.
Checkpoint 5 Passed

5.

Inside the try code block, create a const variable named response and assign it to await the result of calling fetch() with endpoint as the first argument. For this API to work within the Codecademy browser, add {cache: 'no-cache'} as the second argument.
Checkpoint 6 Passed

6.

Below the response variable declaration from the previous step, create a conditional statement that checks if the ok property of the response evaluates to a truthy value.

Inside the code block of the conditional statement, await response.json() and save it to a new const variable called jsonResponse.
Checkpoint 7 Passed

7.

Still inside the conditional statement, call the function renderResponse() and pass in jsonResponse. Then, run the code.

In the input field, type in a word and click the submit button on the web page.

Great, now we have an organized list of words from the GET request!

The declaration of the renderResponse() function can be found at public/helperFunctions.js.

solution;
// Asynchronous function
// Code goes here
const getSuggestions=async () =>{
  const wordQuery=inputField.value;
  const endpoint=url+queryParams+wordQuery;
  try{
    const response=await fetch(endpoint,{cache:'no-cache'});
    if (response.ok){
      const jsonResponse=await response.json();
      renderResponse(jsonResponse);
    }
  }catch(error){
    console.log(error);
  }
}
---
Async await Post response;
  -> now we want to send a Post request using Async, Await to a url endpoint and see the output; in this case; we need method='Post' and object called; json.stringify to do this
ex;
1.

At the top of main.js, assign apiKey to your Rebrandly API key.
Checkpoint 2 Passed

2.

The fetch() function should be inside the try block, which should be inside the shortenUrl() function. In the fetch() function, pass in url as the first argument and an object as the second argument.

In that object you just created, add the following three properties:

    method with a value of 'POST'
    body with a value of data
    headers with a value of the object below:

{
  'Content-type': 'application/json',
  'apikey': apiKey
}

Copy to Clipboard

Run the code. Then paste in the URL again and click the shorten button.

Great job using Rebrandly to shorten your URL!
solution ;
onst shortenUrl = async () => {
	const urlToShorten = inputField.value;
  const data = JSON.stringify({destination: urlToShorten});
  try {
    const response = await fetch(url,  // this is the solution
      // add code here
      {method:"POST",body:data,
      headers:{'Content-type':"application/json",'apikey':apiKey}}
    );
		if(response.ok){
      const jsonResponse = await response.json();
      renderResponse(jsonResponse);
    }
  } catch (error) {
    console.log(error);
  }
}

to sum up this ;

we use fetch to make a request
we use async-await to resolve the promises in order to finish this request (post,get)
async -> make asynchronous function to build a promise
await -> make program suspend untill this promise resolved or reject

